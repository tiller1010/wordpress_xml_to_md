# Presentation was a success


I recently gave a presentation at the Coderie meetup group. My talk was about the strategies I use to teach myself, instead of going through a traditional education system. Many of those who attended the meetup have been in the field for some time or even own businesses of their own. I had some initial jitters about the idea, but I am glad that I was able to leave my comfort zone. I got to talk one on one with some very experienced people who congratulated me on my talk.



In May of this year, I got my first web development Internship. It has been a twelve week program at Werkbot Studios, right in downtown Erie. During this time, I took time off from work so I could continue to my self-education in my spare time. This gave me much more flexibility to practice and learn. I was able to be especially productive with my time Werkbot. I have practiced soft skills such as writing or fixing documentation, sharing ideas, and public speaking. Plus, I have even been able to take on some work of my own!

<img alt="" src="http://tylertroutblog.com/wp-content/uploads/2019/08/silverstripe.png" height="145" width="412" />

A lot of my recent training has been focused on SilverStripe, which is a CMS that, on the surface, looks similar to WordPress. SilverStripe, however, is not just a CMS but also an MVC framework. It is not as simple as editing a theme and installing a few plugins. SilverStripe is largely based around having classes represent page types and having those classes provide fields for the CMS. Templates will then "listen" to the data entered in said fields. SilverStripe is centered around PHP, and despite criticism, I find PHP to be both powerful and readable. A majority of complaints come from the "legacy PHP" stigma that suggests the language is inconsistent with itself. It can be true in a sense, but just remember that most version differences can be found in the documentation. This remains true for SilverStripe, as most questions are answered by the project's contributors. Learning SilverStripe has taught me how to create dynamic websites with an easy to use CMS, and I am interested in using it for my own projects.

<img alt="" src="https://tylertroutblog.com/wp-content/uploads/2019/08/slack.png" height="208" width="401" />

Alongside learning a framework/CMS, I have also been able to pick up on a few soft skills. During my internship, I have had one or more developers available to learn from and to review my code. Whenever I have questions, I can reach out to someone on Slack or leave a comment on a pull request. I have been told it is a good idea to be as descriptive as possible, so that other developers can understand my thought process. Doing so makes it easier to solve problems and helps to improve my communication. I also get to participate in both staff and developer meetings. Here, I get to share my ideas and recent progress, as well as watch how others communicate. The internship has helped me become more confidant when speaking in front of other people.   

<img alt="" src="https://tylertroutblog.com/wp-content/uploads/2019/08/coderie.png" height="78" width="332" />

In addition to the practice I get at Werkbot, I have also developed my communication skills outside of the office. I recently gave a talk at the Coderie Meetup group about my experiences. The idea was given to me by a member of Werkbot. It went very well, and I even wrote a brief blog post about the experience [here](https://tylertroutblog.com/presentation-was-a-success/). Public speaking also helps improve my ability to talk to clients. I have had a few face to face meetings with small business owners who are looking for their own website. In these meetings, I have been able to showcase what I have been working on, as well as receive feedback to move forward with. Not everyone has met with me in person, though I have finished websites for both clients that I met online exclusively and for those I met in person.

During my internship at Werkbot, my skills as a developer have improved greatly. I am able to use SilverStripe to create dynamic websites. I practiced my communication with other developers, staff, and clients. Lastly, I took what I learned, and I applied it to my own work. With no school experience, I feel privileged to have had this opportunity, and it has been an awesome adventure.



As of this writing, I am a few weeks into my first job as a junior web developer. I am thrilled to become part of an active development team. I had practiced and learned on my own, and now I must do so in a team. The first few days have taught me a few things about working in a business setting. I have learned that it is important to keep track of the time that I put into my tasks. I am becoming more familiar with the process of submitting pull requests and receiving code reviews. I have learned to keep track of cards and organize my assignments with Trello.

When working on projects for real clients, it is important to be accurate and transparent with the cost of development. It also helps developers have a better estimate on the amount of time a feature will take to build. That is why it is important for me to track my times. I was introduced to a program called "Minute7". It is a simple and handy tool for tracking time. I simply enter the client, the task, and the times I started and concluded working on a task. It is not overly complex, and it helps those on the business end accurately quote clients and make more informed decisions.

<img alt="" src="https://tylertroutblog.com/wp-content/uploads/2019/09/minute7-1024x576.jpg" height="170" width="302" />

With my new assignments, I get to practice the process of submitting pull requests. I am more comfortable creating branches for specific requests, and leaving helpful descriptions for the developers reviewing my code. After my code is reviewed, I go back through my code to make the appropriate changes. If everything looks good, I merge and delete the branch I was working on. Git and GitHub are very useful and robust tools especially when working in a team.

<img alt="" src="https://tylertroutblog.com/wp-content/uploads/2019/09/maxresdefault-1024x576.jpg" height="154" width="274" />

The team needs to keep track of who does what, so that is where Trello comes in. Trello is what I can use to keep track of the tasks assigned to me, and what the team can use to stay organized with who is doing what. I have learned to provide relevant links to my work, and how some tasks will later be split into tasks with cards of their own. Trello keeps everything organized into separate boards, and it makes it simple to find what needs done.

<img alt="" src="https://tylertroutblog.com/wp-content/uploads/2019/09/Trello-1024x1024.png" height="217" width="217" />

Starting my first job in web development is very exciting. I am learning how a team works to satisfy many clients and create work of high quality. The team must have an estimate on the time an assignment will take, review the code for said assignment, and keep track of who is working on it. It was highly satisfying to complete my first tasks, and I am excited to learn more.  



I recently met with the owner of Dobbins Dogs to finalize his site and launch it. Before we got started, he gifted me with a Dobbins Dogs shirt. I took the opportunity to give him one of my new work business cards. We discussed any final revisions he would want before setting his site up under its domain. You can visit the site at [dobbinsdogs.com](http://dobbinsdogs.com). The site features a single page with testimonials and various contact methods.



With today's modern work-flow, it is easy to feel spoiled with all of our handy tools. Git allows us to rollback to any previous commit in our application, just in case something were to go horribly wrong. A CMS allows us to easily update content without ever touching the code. Package managers like NPM and Composer can provide our project with all of its dependencies simply by running a command. But developers are not always working on new code. A majority of time is spent working on existing code. Some of that code may feel severely antiquated from what we are used to.

Imagine starting on a new project without Git. Scary right? Git is an essential part of today's development. However, you may find yourself working on an older project that does not use version control. To safely make changes you will need to create a backup of every file you change. That way if you do break something you are left SOL. When you are ready to make your changes live, you cannot just pull to a repository. You will need to FTP every file you changed individually. All of this is a huge headache by today's standards. Not only are you at a much higher risk of creating irreversible damage, but you must keep track of moving parts manually.

Content management systems make customizing your pages very simple. With a CMS you can upload content to your site without any need to touch the code. But what if you have a static site made up of several HTML files and no CMS? If you need to make a change to the frame of your site (navigation, footers, etc...), that change will have to be made across several files. Now, you could use a search and replace tool to make this happen all at once, but what if you have something like a "selected" class on navigation items? Each page will have the same navigation but with a unique selected value. You can start to imagine the headache of editing nearly identical elements across several files. With most content management systems, this is all taken care of.

With package managers, by running a single command, you can install all of your projects dependencies. Older projects may not be fortunate enough to include this. When working on a project like this, you may need to individually initiatialize and update submodules. It can be unclear what packages your project requires You may find yourself refreshing your browser until the errors are gone. With tools like Composer and NPM, these concerns are eliminated, so you can spend more time working on your project than resolving dependency issues.

Modern tools make our lives as developers much easier. However, we still find ourselves supporting older projects without these amenities. Working with these systems is far from impossible, but more caution and patience is often required.



Imagine if every time you needed to start your car, you first had to install the engine. No one would ask to borrow your car, but you would be reluctant to use it yourself. No one wants a mundane task to take anymore time and effort than is required. Simple problems should have simple solutions, and updates to our websites should be painless. A site that works on one machine, should work on any machine. A site that needs a single change in punctuation on a single page, should not require a developer.

Development of a website often begins locally. The site is installed on the same computer the developer works with. When the site is finished, it is often staged in a development environment. The website is accessible from the internet, but it is not yet optimized for the public. When the site is ready to go live, it is installed again in a separate production environment. The site should function nearly identical in all three environments, but certain things should behave differently. In the case of an overlooked fatal error, we wouldn't want to show an end-user a long error trace; only the developer cares about that sort of thing. When entering payment information, we wouldn't want a real transaction to occur during development. Our site should behave differently in subtle ways, depending on our environment. Managing three different codebases for each environment would be highly inefficient and prone to errors. This is where environment variables come into play. With a single configuration file, we can control every setting that should differ in each instance of our site. The code should read the declared environment variables, and decide whether it should actually charge a debit card, or run a fake transaction in a test sandbox.

<img alt="" src="https://tylertroutblog.com/wp-content/uploads/2020/09/environment.jpg" height="328" width="493" />In windy environments, wind turbines are highly effective at producing power

Implementing this workflow means that updates for a website are relatively painless for everyone. You and your customers will not have to sweat nervously when making changes that could range from small to dramatic. A developer can work comfortably in a local environment, free to break anything without consequence. Compare this to working on a production site blindly. Both parties risk facing devastating consequences while making changes live and on the fly.

<img alt="" src="https://tylertroutblog.com/wp-content/uploads/2020/09/solar-panel.jpg" height="326" width="492" />Also a source of power, solar panels are more appropriate in sunny environments  

Think about installing your car engine to drive again. If you are a mechanic, this might feel tedious and time-consuming, but you are confident in your ability to start the car. Now, imagine that the only thing that you are familiar with is the brake pedal, gas pedal, and steering wheel. Starting that car is going to feel intimidating and daunting. You may just decide to walk that day.

Your customers do not want to install an engine just to drive. When it comes to their website, content should be updated easily, without any need to touch code. Thankfully, we have Content Management Systems to solve this problem. A developer will write code that will define page types and data objects. This code will make use of templates to layout the content of the site. From this point, content can be entered in a user-friendly Graphical User Interface and published to the site. A great Content Management System, as well as my personal favorite, is SilverStripe. SilverStripe makes both the developers and customers' lives easier when bringing sites to life. Silverstripe is clean and comprehensible, both in its code and in its user interface. You can check out my tutorials on the SilverStripe CMS and Framework here [https://www.youtube.com/watch?v=XVOianFRSl0](https://www.youtube.com/watch?v=XVOianFRSl0)

![](http://tylertroutblog.com/wp-content/uploads/2019/08/silverstripe.png)Learn SilverStripe and save everyone some headache  

KISS is not only a hard rock band from the 1970s, but a clever acronym when avoiding complexity. Keep It Simple Stupid. You and your customers do not want risky changes made to a site running in production. Your customers want things to be as easy as pie. Give them a CMS that both of you will love. Just remember to KISS; everyone enjoys it.



Have a business but need a new website? Do you want to see your brand online? Head over to [my site](https://tylertrout.com) and see today!

Upload your logo, a banner, and your brand's colors. Voila! A freshly generated site template just for you! Be sure to leave me a message when you want to get serious about your online presence.



Most of us Web Developers have never had the experience of building a mobile app. The task may seem daunting and out of the usual comfort zone. You might be starting with no Java or Swift experience. Learning both will take some time, and you would need to manage two codebases. Lucky for us, there is React Native and Expo.

<img alt="" src="https://tylertroutblog.com/wp-content/uploads/2021/01/reactNative-1024x512.png" height="228" width="456" />Create cross-platform mobile apps with React Native

React Native lets us developers write mobile apps in React, no Java or Swift experience required. Expo further simplifies the development process. It provides commonly used libraries. It sets up a development environment. It provides debugging tools and much more. With both of these tools, some React experience, and some wit, any web developer can develop their app for iPhone and Android. If you follow these steps, you too can transform your web-based React code into working React Native code.

<img alt="" src="https://tylertroutblog.com/wp-content/uploads/2021/01/expo.png" height="201" width="411" />Simplify development. Spend less time getting set up and more time building your app.

The "\<div\>" tag is perhaps the most commonly used element when it comes to web development. React Native has its own version of "\<div\>": the "\<View\>". Views are used to wrap content areas in your app's layout. Go ahead, copy and paste your web-based React code into your expo app, run a search for "div" and replace it with "View". Your project may contain other wrappers such as "\<section\>" or "\<article\>". Be sure to replace these as well. Your content wrappers are now native friendly, and you are one step closer to transitioning your app to mobile. Now, let's take care of the text content.

On the web, there are many different types of text tags. You could have headers in the form of "\<h1\>" down to "\<h6\>". Your project might have text in "\<span\>", "\<p\>", or "\<label\>" tags. Anywhere there is text, we will replace the tags with the "\<Text\>" element. Do this with any plain text in your project, but you can skip any links that use the "\<a\>" tag for now. This will be handled by a different React Native component, which we will cover next.

Links on the web use the anchor tag: "\<a\>" with an "href" attribute describing the link's destination. We will replace these links with the React Native "\<Button\>" element. The text within the link should be moved to the "title" prop of the Button (e.g. \<Button title="Click me"/\>). As for the "href", you will instead define a function to navigate to a screen. This will be placed within the "onPress" prop. [Here is a more in-depth guide](https://reactnative.dev/docs/navigation) on how to do this. Some links may also pass data in the form of "GET" variables (e.g. "http://example.com?foo=bar"). The variable "foo" has the value of "bar". In React Native, you can pass data as an object in the second argument of the navigation function. You would instead write something like: "navigation.navigate('Example', {foo: 'bar'})".

 You still may need to update "\<input\>"s to "\<TextInput\>"s or "\<video\>"s to "\<Video\>"s, but by now you should see that for every web element, there is a React Native equivalent component. Take some time to confirm each HTML tag is replaced with the appropriate component. With all of these changes, your app should be well on its way to working on iPhone and Android.



Have you ever found yourself writing code with a sense Déjà vu? You feel as though the code you are writing has already been written somewhere else. This could potentially be within the same project or even the same file. You do not want to be stuck repeating yourself and you do not want to waste time finding answers to the problems you have already solved. You might already be familiar with the "DRY" principle (Don't Repeat Yourself). Repeating code not only makes your project look sloppy and difficult to read (and therefore manage); it increases the likelihood of bugs and makes the code more difficult to manage. Here are a few helpful tips for producing PHP code that you can use often, but write only once.

Use Modules
----------

Modules are reusable packages that can be included across several of your projects. Modules isolate the functionality of one of your project's features, allowing you to maintain these features separately from your projects. You might have several PHP-powered websites, most of which connect to social media platforms. Therefore, you might create a module just for managing your social media accounts. Such a module should not be overly concerned with the particular project it is included in but instead should only care about storing data related to social media sites. Perhaps the module would also provide some sort of front-end component to render this data such as icon links to each social network site. If an update were to be added to support some new feature (perhaps a selectable list of icons), then the update would be made to the module itself and not the websites. Any site that uses this module could receive the update by [running composer](https://getcomposer.org/).

Modules are typically namespaced, meaning their classes can only be used in a project when explicitly including it. For example, the full class name for social media links might look something like "Vendor\\SocialMedia\\SocialMediaLink". You could use this class directly by prepending the class with a backslash like:

```
$facebook = new \Vendor\SocialMedia\SocialMediaLink();
```

Or you could include the class with the "use" statement:

```
use Vendor\SocialMedia\SocialMediaLink; $facebook = new SocialMediaLink();
```

Namespacing your modules ensures that the class names never conflict with those that are defined globally.

Write Methods for common actions
----------

There are some processes that will need to occur in several areas of your project. This could be something like formatting dates. It is usually a good idea to keep a consistent date format across a project. Your code could have several functions to retrieve dates, but it could be repeating the same code that formats the date in each. It might make sense for you to write a method just for formatting the dates. With one reusable method for date formatting, you will not find yourself writing the same code in several areas.

Sticking to this idea, consider the purpose of each function before writing. If the function requires several separate processes to occur before the main goal is achieved, it would make sense to break each task out into a separate function. Doing this makes your code more readable and more reusable. For example, your code might have a method that retrieves and renders blog articles that have been marked "Published". We will call this method "renderPublishedArticles". If your website has a content management system, it would be a good idea to flag unpublished articles. The code here will likely use a method like "getAllArticles" to list articles in the CMS. Instead of repeating code to check if articles are published in both methods, a better solution would be to write a method that just checks the "Published" status of an article. This method might be named "getPublishedArticles". The "renderPublishedArticles" and "getAllArticles" methods would both call this method. Because the functionality has been encapsulated in a function name, we know exactly what is happening when reading the code for each method.

If a change has to be made, the change is made in one area of the code, rather than each time the code is repeated. In the case of our date formatting method, we might opt for a different date format. You will thank youself later for writing reusable methods when changes like this are necessary.

Use Classes to Encapsulate Components
----------

If you are familiar with Object-Oriented Programming (OOP), you know that you can use classes to encapsulate certain behaviors of your components. In object-oriented programming languages like PHP, you might have a class that represents some type of model. That model will be responsible for defining some data structure, and it will likely provide methods to interact with related components. For example, you might have a class called "Page". This model might define fillable database fields like "HTML Content" and "Featured Images". This class could have methods to interact with these relationships, such as a "getRecentFeaturedImages" method.

A website will commonly have different types of pages. Some functionality should be shared between all pages, but some pages will have different concerns. For example, a blog page might be responsible for storing and fetching written articles. A home page will usually feature a large banner image, video, or slideshow. If we want our "Page" class to be extendable, it should only be concerned with the functionality that should be shared across every page type. We could then extend the Page class for each page type and add the appropriate functionality:

```
class Page{ // Define the functionality that should exist on all pages ...}class HomePage extends Page{  // This inherits from "Page", so just define everything unique to a Home Page ...}
```

Conclusion
----------

Writing reusable code has a plethora of benefits, as you have seen. Employing these tips means writing code that is consistent everywhere, even across projects. When many common actions are abstracted into separate methods, the code will naturally become more readable and declarative, as most methods will call other methods, each with descriptive names. When functionality needs to be shared between components, having a shared base class that each extends means writing less code overall. While it might be easy to simply paste in some code that is already used somewhere else, it will be more difficult to maintain later on should things change. Instead, think about how to keep each bit of your code clear in its purpose, so that it is reusable, should you need it for something else tomorrow.



Imagine this: you want to add a new feature to a repository, but it involves a change that will break backward compatibility. You could release a new major version, but other repositories may depend on the previous version of your software. In this case, you need to support an older version simultaneously with the next major version. Git-flow is a branching strategy that eases the burden of managing multiple versions, but it can be tricky to implement in a team using GitHub. Git-flow provides several benefits:

* Git-flow uses distinct and obvious branch roles: branches are annotated with their specific purpose (feature, release, support, and hotfix).
* Git-flow keeps consistent histories: patches made for older versions are automatically merged back into the development branch.
* Git-flow uses a release branching strategy that ensures a higher quality of released software, and lower stress for the developer managing branches, as release branches are deleted as soon as they are merged and tagged.

These benefits can be achieved in a GitHub setting, but it requires some manual automation with GitHub actions.

"feature/feature\_name" into "develop"
----------

All new features should be created from the "develop" branch. No GitHub actions need to run on pull requests created for feature branches into the develop branch, but you may choose to enforce labels on your features. Making sure the feature in review has the appropriate semantic versioning label will be helpful for when we create "release" branches later.

Draft a release on "release/\*" push
----------

By far the best benefit of using git-flow with GitHub is that releases can be properly reviewed in the form of a pull request. A GitHub action could be created that drafts a release when a push is made to a "release/\*" branch.

```
on:  push:    branches:      - release/*permissions:  contents: readjobs:  update_release_draft:    permissions:      contents: write    runs-on: ubuntu-latest    steps:      - name: Checkout        uses: actions/checkout@master      # Get the release tag      - name: Get release Tag        id: get_release_tag        run: |          RELEASETAG=$(git branch | grep \* | sed -re "s/release\///;s/\*//;s/\s*//g")          echo "::set-output name=release_tag::$RELEASETAG"      # Draft Release with release branch      - name: Draft Release with release branch        id: update_release_draft_with_release_branch        uses: release-drafter/release-drafter@master        with:          tag: ${{ steps.get_release_tag.outputs.release_tag }}        env:          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

Publish the draft release when "release/\*" PRs are merged
----------

When a release branch is merged into "main" the release that was drafted for that pull request can be published. Doing so creates a tag. After the corresponding release is published, the "release/\*" branch can be automatically deleted by a GitHub action.

```
on:  pull_request:    types:      - closed    branches:      - mainjobs:  publish_release:    if: ${{ github.event.pull_request.merged }}    runs-on: ubuntu-latest    steps:      # Get the latest draft release. This requires authentication.      - name: Get release id        id: get_release_id        run: |          TOKEN=${{ secrets.GITHUB_TOKEN }}          RELEASEID=$(curl -H "Accept: application/vnd.github+json" -H "Authorization: token $TOKEN" https://api.github.com/repos/[YOURNAME]/[REPONAME]/releases)          RELEASEID=$(echo "$RELEASEID" | grep \"id\"  | head -n 1 | sed -re "s/[a-z]*//g;s/[-|,|:|'\"]//g;s/\s//g")          echo "::set-output name=release_id::$RELEASEID"        env:          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}      # Publish the release draft      - name: Publish release        uses: eregon/publish-release@v1        env:          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}        with:          release_id: ${{ steps.get_release_id.outputs.release_id }}      # Get payload info from the pull request      - name: Payload info        id: payload_info        uses: Dovyski/payload-info-action@master        continue-on-error: true      # Remove the release or hotfix branch after publishing      - name: Remove PR branch        uses: dawidd6/action-delete-branch@v3        with:          github_token: ${{github.token}}          branches: ${{ steps.payload_info.outputs.branch }}
```

Merge main into develop
----------

After a release branch is merged into the main branch, it should be merged back into the "develop" branch. Optionally, you could set GitHub actions to create a commit that updates a CHANGELOG.md file before this merge occurs.

```
on:  push:    branches:      - mainpermissions:  contents: writejobs:  sync_develop:    runs-on: ubuntu-latest    steps:      - name: Checkout        uses: actions/checkout@master      - name: Merge main -> develop        uses: devmasx/merge-branch@master        with:          type: now          from_branch: main          target_branch: develop          github_token: ${{ secrets.GITHUB_TOKEN }}          message: Merged main into develop
```

Draft releases on "hotfix/\*" push
----------

When you must support a previous minor or major version, you should start by checking out that tag. Make sure to checkout the latest patch for that minor or major version. Then, you should create a "support/\*.x" branch. Support branches should function similarly to the "main" branch. Tags will be created when "hotfix/\*" branches are merged into it, and commits should **not** be added to it directly. After creating the support branch, a "hotfix/\*" branch with the next patch number should be created. These are similar to the "release/\*" branches, as they should be reviewed in a pull request, and when they are merged, Git actions should **publish** the drafted release and delete the "hotfix/\*" branch (similar to when a "release/\*" branch is merged, see the above example).

```
on:  push:    branches:      - hotfix/*jobs:  update_release_draft:    permissions:      contents: write    runs-on: ubuntu-latest    steps:      - name: Checkout        uses: actions/checkout@master      # Get the hotfix tag      - name: Get hotfix Tag        id: get_hotfix_tag        run: |          RELEASETAG=$(git branch | grep \* | sed -re "s/hotfix\///;s/\*//;s/\s*//g")          echo "::set-output name=release_tag::$RELEASETAG"      # Draft Release with hotfix branch      - name: Draft Release with hotfix branch        id: update_release_draft_with_hotfix_branch        uses: release-drafter/release-drafter@master        with:          tag: ${{ steps.get_hotfix_tag.outputs.release_tag }}        env:          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

Merge support into main and develop
----------

If a bug existed in a previous version, it is likely that it still exists in the latest version too. Similar to "release/\*" branches that are merged into the main branch, support branches too should be merged into the main branch and then merged again into the develop branch when a "hotfix/\*" branch is merged into one. There is, however, a higher potential for this merge to conflict with the main branch. In that case, a developer must resolve the conflict on their own, and push the resolved merge into the main branch.

```
on:  push:    branches:      - support/*permissions:  contents: writejobs:  sync_develop:    runs-on: ubuntu-latest    steps:      - name: Checkout        uses: actions/checkout@master      # Get the support branch      - name: Get support branch        id: get_support_branch        run: |          SUPPORTBRANCH=$(git branch | grep \* | sed -re "s/[\*|\ ]//g")          echo "::set-output name=support_branch::$SUPPORTBRANCH"      - name: Merge support -> main        uses: devmasx/merge-branch@master        with:          type: now          from_branch: ${{ steps.get_support_branch.outputs.support_branch }}          target_branch: main          github_token: ${{ secrets.GITHUB_TOKEN }}          message: Merged ${{ steps.get_support_branch.outputs.support_branch }} into main      - name: Merge main -> develop        uses: devmasx/merge-branch@master        with:          type: now          from_branch: main          target_branch: develop          github_token: ${{ secrets.GITHUB_TOKEN }}          message: Merged main into develop
```

I hope you decide to use git-flow in your projects! It adds much-needed sanity to the management of multiple versions of software.

